"""
Написать скрипт, который выводит статистику для заданной папки в виде словаря, в котором ключи — верхняя граница размера
файла (пусть будет кратна 10), а значения — общее количество файлов (в том числе и в подпапках), размер которых не
превышает этой границы, но больше предыдущей (начинаем с 0), например:
    {
      100: 15,
      1000: 3,
      10000: 7,
      100000: 2
    }

Тут 15 файлов размером не более 100 байт; 3 файла больше 100 и не больше 1000 байт...
Подсказка: размер файла можно получить из атрибута .st_size объекта os.stat.
*(вместо 4) Написать скрипт, который выводит статистику для заданной папки в виде словаря, в котором ключи те же, а
значения — кортежи вида (<files_quantity>, [<files_extensions_list>]), например:
    {
      100: (15, ['txt']),
      1000: (3, ['py', 'txt']),
      10000: (7, ['html', 'css']),
      100000: (2, ['png', 'jpg'])
    }

Сохраните результаты в файл <folder_name>_summary.json в той же папке, где запустили скрипт.
"""

import os
import json

ROOT = os.path.join(os.path.dirname(os.path.abspath(__file__)), 'files')

dict_result = dict()
# Проходим рекурсивно по всем папкам, начиная от корневой
for (dir_path, dir_names, file_names) in os.walk(ROOT):
    # Перебираем все файлы в папке
    for entry in os.scandir(dir_path):
        if entry.is_file():
            # Ключ для словаря = 1 плюс столько нулей, сколько цифр в размере файла
            key_size = '1' + len(str(entry.stat().st_size)) * '0'
            # Расширение файла
            file_extension = os.path.splitext(entry.name)[1].lstrip('.')
            # Если такой ключ уже есть в словаре
            if key_size in dict_result:
                # Увеличиваем счетчик
                dict_result[key_size][0] += 1
                # Добавляем расширение в множество. Множество выбрано для того, чтобы элементы не повторялись
                dict_result[key_size][1].add(file_extension)
            # Если ключа еще нет в словаре
            else:
                # Добавляем ключ в словарь со значением по умолчанию. По умолчанию это список из двух элементов
                # (целое число для счетчика и множество для накопления расширений)
                dict_result[key_size] = [1, {file_extension}]

# Преобразуем словарь под формат, требуемый по условию. Значения - кортежи, множества преобразовывем в списки
dict_result = {k: (v[0], list(v[1])) for k, v in sorted(dict_result.items())}

print(dict_result)

# Запись результата в файл json
with open(f'{os.path.basename(ROOT)}_summary.json', 'w', encoding='UTF-8') as json_file:
    json.dump(dict_result, json_file, indent=4)
